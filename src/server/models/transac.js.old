import {Event} from './event';
import {dmy} from '../helpers';

let moment = require('moment')
    , async = require('async')
    , _ = require('lodash');


export class ElementaryTransac{
  constructor({server, user, processId} = {}){
    this.processingTime = new Date();;
    if(server) this.server = server;
    if(user) this.user = user;
    if(processId) this.processId = processId;
    this.events = [];
  }

  toJSON(){
    return {
      processingTime: +this.processingTime,
      status: this.status,
      isRunning: this.isRunning(),
      server: this.server,
      user: this.user,
      processId: this.processId,
      delay: this.delay,
      events: _.map(this.events, function(event){return event.toJSON()})
    }
  }

  addEvent(event){
    if(!this.isRunning()) throw new Error("Cannot add an event on a non running transac");
    if(!this.events)this.events = [];
    this.events.push(event);
    return this;
  }

  get status(){
    if(this.hasEventTypes(['error', 'abort'])) return 'error';
    if(this.hasEventTypes(['warning'])) return 'warning';
    return 'ok';
  }

  hasEventTypes(types){
    return _.some(this.events, function(event){return _.contains(types, event.type)});
  }

  isRunning(){
    return !this.hasEventTypes(['abort', 'commit']);
  }

  get lastEvent(){
    return this.events && this.events[this.events.length - 1];
  }

  get lastEventTime(){
    return this.lastEvent && this.lastEvent.time;
  }

  get delay(){
    if(this.lastEvent) return this.lastEvent.time - this.processingTime;
    else return 0;
  }
}

ElementaryTransac.schema = ['processingTime', 'server', 'user', 'events', 'processId'];

export class Transac{
  constructor({name, valueDate=moment().startOf('day').toDate(), locked=false} = {}){
    this.name = name;
    this.valueDate = valueDate;
    this.locked = locked;
    this.processingTime = new Date();
  }

  static Factory(options){
    return options.nested ? new MultiTransac(options) : new PlainTransac(options);
  }

  static get collection(){ 
    return "transacs";
  }

  static bless(transac){
    if(!transac)return;
    switch( transac.type ){
      case 'plain':
        transac.__proto__ = PlainTransac.prototype;
        _.each(transac.events, function(event){
          event.__proto__ = Event.prototype;
        });
        return transac;
      case 'multi':
        transac.__proto__ = MultiTransac.prototype;
        _.each(transac.nestedTransacs, function(nt){ 
          nt.__proto__ = ElementaryTransac.prototype;
          _.each(nt.events, function(event){
            event.__proto__ = Event.prototype;
          });
        });
        return transac;
    }
  }


  isLocked(){
    return this.locked;
  }

  isMulti(){
    return this.type == 'multi';
  }

  toSummaryJSON(){
    return {
      id: this.id,
      name: this.name,
      valueDate: dmy(this.valueDate),
      processingTime: +this.processingTime,
      lastEventTime: this.lastEventTime && +this.lastEventTime,
      locked: this.isLocked(),
      status: this.status,
      isRunning: this.isRunning(),
      isMulti: this.isMulti(),
      server: this.server,
      delay: this.delay
    }
  }
}

export class PlainTransac extends mixin2(Transac, ElementaryTransac){

  constructor({name, valueDate, server, user, processId, locked} = {}){
    super({name: name, valueDate: valueDate, locked: locked});
    this.type = 'plain';
    if(server) this.server = server;
    if(user) this.user = user;
    if(processId) this.processId = processId;
    this.events = [];
  }

  toJSON(){
    return {
      id: this._id,
      name: this.name,
      valueDate: dmy(this.valueDate),
      processingTime: +this.processingTime,
      lastEventTime: +this.lastEventTime,
      locked: this.isLocked(),
      status: this.status,
      isRunning: this.isRunning(),
      isMulti: this.isMulti(),
      server: this.server,
      user: this.user,
      processId: this.processId,
      delay: this.delay,
      events: _.map(this.events, function(event){return event.toJSON()})
    }
  }

};


export class MultiTransac extends Transac{

  constructor({name, valueDate, locked, server, user, processId} = {}){
  
    super({name: name, valueDate: valueDate, locked: locked});
    this.type = 'multi';
    this.nestedTransacs = [new ElementaryTransac({server: server, user: user, processId: processId})];
  }

  toJSON(){
    return {
      id: this._id,
      name: this.name,
      valueDate: dmy(this.valueDate),
      processingTime: +this.processingTime,
      lastEventTime: +this.lastEventTime,
      locked: this.isLocked(),
      status: this.status,
      isRunning: this.isRunning(),
      isMulti: this.isMulti(),
      server: this.server,
      delay: this.delay,
      nested: _.map(this.nestedTransacs, function(nt){return nt.toJSON()}),
    }
  }

  addEvent(event){
    this.lastElementaryTransac.addEvent(event);
  }

  addNestedTransac(transac){
    this.nestedTransacs.push(transac);
  }

  get lastElementaryTransac(){
    return this.nestedTransacs[this.nestedTransacs.length - 1];
  }

  get lastEvent(){
    return this.lastElementaryTransac.lastEvent;
  }

  get lastEventTime(){
    return this.lastElementaryTransac.lastEventTime;
  }

  isRunning(){
    return this.lastElementaryTransac.isRunning();
  }

  get status(){
    if(_.some(this.nestedTransacs, function(transac){return transac.status === 'error' || transac.status === 'abort' })) return 'error';
    if(_.some(this.nestedTransacs, function(transac){return transac.status === 'warning' })) return 'warning';
    return 'ok';
  }

  get delay(){
    return _.inject(this.nestedTransacs, function(sum, transac){ return sum + transac.delay }, 0);
  }

  get server(){
    return this.lastElementaryTransac.server;
  }

  get user(){
    return this.lastElementaryTransac.user;
  }

  get processId(){
    return this.lastElementaryTransac.processId;
  }

}


function mixin(target, ...sources) {
  for(let source of sources){
    Object.getOwnPropertyNames(source.prototype).forEach(function(property) {
      if(property != 'constructor') Object.defineProperty(target, property, Object.getOwnPropertyDescriptor(source.prototype, property));
    });
  }
  return target;
}

function mixin2(superKlass, ...mixins) {
  let target = class extends superKlass {};
  for(let mixin of mixins){
    Object.getOwnPropertyNames(mixin.prototype).forEach(function(property) {
      if(property != 'constructor') Object.defineProperty(target.prototype, property, Object.getOwnPropertyDescriptor(mixin.prototype, property));
    });
  }
  return target;
}


